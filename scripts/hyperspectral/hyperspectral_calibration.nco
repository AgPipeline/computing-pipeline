// -*-C++-*-

/* Purpose: NCO/ncap2 script to process and calibrate Terraref exposure data

   Documentation:
   https://docs.google.com/document/d/1w_zHHlrPVKsy1mnW9wrVzAU2edVqZH8i1IZa5BZxVpo/edit#heading=h.jjfbhbos05cc # Calibration employed since 20160908
   https://github.com/terraref/computing-pipeline/issues/88 # Calibration employed until 20160908

   Usage:
   ncap2 -v -O -S ~/terraref/computing-pipeline/scripts/hyperspectral/hyperspectral_calibration.nco ${DATA}/terraref/whiteReference_raw.nc ~/foo.nc */

// Declare flags as RAM variables or they will clutter output file
*flg_tst=1s; // [flg] Test mode
*flg_prd=0s; // [flg] Production mode
*flg_vnir=0s; // [flg] VNIR image
*flg_swir=0s; // [flg] SWIR image

// Run in test or production mode?
*flg_typ=flg_prd; // [enm] Run type

// Defaults for values not provided on command-line
if(!exists(clb_nbr)) *clb_nbr=73; // [nbr] Calibration number
if(!exists(drc_spt)) *drc_spt="."; // [sng] Script directory

// Change hyperspectral camera wavelengths from nm to m (SI)
wavelength*=1.0e-9; // [m]
wavelength@standard_name="radiation_wavelength";  
wavelength@units="meter";  

/* 20161005 Set flags to separate blocks of VNIR from SWIR code when necessary */
if(min(wavelength < 0.5e-6)){
  flg_vnir=1s;
  *wvl_pxl_nbr=2160;
  *x_pxl_spc=0.001025; // [m]
 }else{
  flg_swir=1s;
  *wvl_pxl_nbr=288;
  *x_pxl_spc=0.001930615052; // [m]
 } // !wavelength

// Add georeferenced coordinates
// Store x and y in double-precision in case we use lat/lon
// If stored as meters from image or gantry corner, then single-precision might be adequate
x=array(0.0,x_pxl_spc,$x);
x@long_name="North distance from southeast corner of field";
x@units="meter";
x@orientation="The x-dimension (which runs north-south) spans what are called samples or pixels. The y-dimension (which runs east-west) spans what are called lines or scanlines. Normal, non-calibration images have the same number of pixels (384 or 1600 for SWIR and VNIR, respectively) and a variable number of lines set by the number of frames (images) the camera takes as the camera box moves east-west.";
x@algorithm="Based on https://github.com/terraref/computing-pipeline/issues/144, x is derived from camera geometry including the Aperature Field-of-View (AFOV), the Horizontal Field-of-View (HFOV), and the height of the camera above the canopy (aka the Working Distance, or WD). We take WD = 2 m. Focal length (about 25 mm) is ignored in this estimate because it is much smaller than the WD. The camera geometry implies that AFOV[degrees]=2*atan(HFOV/WD). We use AFOV=21 and 44.6 degress for SWIR and VNIR, respectively. Then we solve for HFOV, and that distance is equally apportioned to 384 or 1600 pixels for SWIR or VNIR, respectively. For SWIR x = 1.93mm, for VNIR x = 1.025mm.";

y=array(0.0,0.00098526434004512529576754637665,$y);
y@long_name="West distance from southeast corner of field";
y@units="meter";
y@orientation="The x-dimension (which runs north-south) spans what are called samples or pixels. The y-dimension (which runs east-west) spans what are called lines or scanlines. Normal, non-calibration images have the same number of pixels (384 or 1600 for SWIR and VNIR, respectively) and a variable number of lines set by the number frames (images) the camera takes as the camera box moves east-west.";
y@algorithm="Based on https://github.com/terraref/computing-pipeline/issues/144. The y-dimension spans 0.9853 mm per scanline. Exact number is 0.98526434004512529576754637665 mm.";
  
// [W m-2 m-1] Downwelling spectral irradiance
// 20160908 This is a placeholder for irradiance on the hyperspectral grid 
// Currently no instrument measures this
// The only irradiance measured in by the Environmental Logger, which has a different (and non-overlapping) spectral grid
//flx_dwn[wavelength]=2.0e9f;
//flx_dwn@long_name="Downwelling spectral irradiance";
//flx_dwn@standard_name="surface_downwelling_radiative_flux_per_unit_wavelength_in_air";
//flx_dwn@units="watt meter-2 meter-1"; 

/* Calibrate hyperspectral image from raw counts to reflectance
   Optimal calibration would have this equal 2^16-1 in each channel for a perfectly white reflector
   This parameter depends solely on the bit-resolution of the camera (currently 16 bits) */
*exposure_theoretical_maximum=ushort(2^16-1); // [cnt]

/* Assume spectral reference target employed is "white" reference sheet that reflects all wavelengths with 95% efficiency
   (Some) Documentation for spectralon reference targets at
   https://github.com/terraref/reference-data/issues/36
   https://github.com/terraref/reference-data/issues/53

   20160927: fxm replace guesstimate with actual, wavelength-dependent calibrated reflectance below */
*factory_calibrated_reflectance_guesstimate=0.95f; // [frc]

@fl_clb=push(@drc_spt,"/hyperspectral_spectralon_reflectance_factory.nco");
//print(@fl_clb," = %s\n");
#include "hyperspectral_spectralon_reflectance_factory.nco"

/* Interpolate factory calibration of spectralon target to wavelength grid of current instrument (VNIR, SWIR) */
gsl_interp_cspline(&ram_ntp_spl,wvl_clb,factory_calibrated_reflectance);
factory_calibrated_reflectance_interpolated=gsl_spline_eval(ram_ntp_spl,wavelength);
ram_delete(ram_ntp_spl);

/* exposure_reference is exposure measured when pointing at spectralon reference target
   Camera exposed to natural light reflecting from reference target for standard exposure time accumulates exposure_reference counts in each channel
   Expected to be large fraction (assumed here to be factory_calibrated_reflectance_guesstimate) of exposure_theoretical_maximum for white reflector 
   However, grey reference reflector might be more optimal than white
   Plants have maximum reflectance of ~0.4 so calibrating at white (~0.95) not as accurate as calibrating near 0.4 
   We hope Lemnatec tunes exposure time to achieve the greatest dynamic range, and thus precision, under a wide range of circumstances
   One tuning consideration is that maximum exposure for white reflector at noon is close to but does not exceed exposure_theoretical_maximum 
   Other tuning considerations are possible... */
// 20160908: actual values are not yet available so use this guesstimate
*exposure_reference_guesstimate=ushort(factory_calibrated_reflectance_guesstimate*exposure_theoretical_maximum); // [cnt]
*maximum_plant_reflectance_guesstimate=0.37f; // [frc]

// A perfect detector would measure no counts when aperture shut
*exposure_theoretical_minimum=ushort(0); // [cnt]

// A real detector exposed to darkness for standard exposure time accumulates exposure_dark counts in each channel
// 20160908: actual values are not yet available so we use this guesstimate
*exposure_dark_guesstimate=ushort(10); // [cnt]

xps_img_max=xps_img.max($y,$x);
xps_img_max@long_name="Maximum image exposure at each wavelength";
xps_img_max@units="Counts on scale from 0 to 2^16-1 = 65535";

// [cnt] Exposure from spectralon reference target
//xps_rfr[wavelength,x]=exposure_reference_guesstimate; // Produces reflectances too small by ~10^5
xps_rfr[wavelength,x]=ushort(xps_img_max*(factory_calibrated_reflectance_guesstimate/maximum_plant_reflectance_guesstimate));
xps_rfr@long_name="Exposure from spectralon reference target";
xps_rfr@units="Counts on scale from 0 to 2^16-1 = 65535";

xps_img_min=xps_img.min($y,$x);
xps_img_min@long_name="Minimum image exposure at each wavelength";
xps_img_min@units="Counts on scale from 0 to 2^16-1 = 65535";

// [cnt] Exposure from dark current image
xps_drk[wavelength,x]=xps_img_min*0.01f;
xps_drk@long_name="Exposure from dark current image";
xps_drk@units="Counts on scale from 0 to 2^16-1 = 65535";

// [frc] Reflectance of spectralon reference target (from factory calibration)
// 20160908: fxm track this down, possibly add angular dependence...
rfl_rfr_fct[wavelength]=factory_calibrated_reflectance_guesstimate;
rfl_rfr_fct@long_name="Reflectance of Spectralon reference target (from factory calibration)";
rfl_rfr_fct@units="1";

// [cnt/cnt] Proportionality constant between factory-calibrated reflectance and current image and field calibration
// 20160908: No real reason to use or archive this
//rfl_img_prp=(xps_img-xps_drk)/(xps_rfr-xps_drk);

// [frc] = Reflectance of image (plant reflectance)
// 20160826: Pre-assigning to zero would create additional copy and increase required memory
// Instead use implicit casting, and overwrite attributes propagated from rfl_rfr_fct
//rfl_img[wavelength,y,x]=0.0f;
rfl_img=rfl_rfr_fct*(xps_img-xps_drk)/(xps_rfr-xps_drk);
rfl_img@long_name="Reflectance of image";
rfl_img@standard_name="surface_albedo";
rfl_img@units="1";
  
